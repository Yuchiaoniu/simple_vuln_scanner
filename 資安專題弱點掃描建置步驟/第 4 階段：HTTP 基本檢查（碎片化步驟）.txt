ğŸ“Œ ç¬¬ 4 éšæ®µï¼šHTTP åŸºæœ¬æª¢æŸ¥ï¼ˆç¢ç‰‡åŒ–æ­¥é©Ÿï¼‰
4.1 ç™¼é€ GET /
ç›®çš„ï¼š å˜—è©¦å­˜å–ç¶²ç«™é¦–é ï¼Œå–å¾—å›æ‡‰ã€‚

æ–¹æ³•ï¼š ä½¿ç”¨ requests.get("http://127.0.0.1:80/") æˆ– http.clientã€‚

è¼¸å‡ºï¼š status codeã€headersã€bodyã€‚

4.2 æª¢æŸ¥æ˜¯å¦æœ‰ directory listing
åˆ¤æ–·ï¼š åœ¨å›æ‡‰ body æœå°‹ <title>Index of /</title> æˆ– Index of /ã€‚

çµæœï¼š

å­˜åœ¨ â†’ ã€Œå¯èƒ½å­˜åœ¨ç›®éŒ„åˆ—å‡ºæ¼æ´ã€

ä¸å­˜åœ¨ â†’ ã€Œæœªç™¼ç¾ç›®éŒ„åˆ—å‡ºã€

4.3 æª¢æŸ¥æ•æ„Ÿ header
æª¢æŸ¥é …ç›®ï¼š

Server â†’ æ˜¯å¦æ´©æ¼ç‰ˆæœ¬è³‡è¨Š

X-Powered-By â†’ æ˜¯å¦æ´©æ¼æ¡†æ¶ç‰ˆæœ¬

X-AspNet-Version â†’ æ˜¯å¦æ´©æ¼ ASP.NET ç‰ˆæœ¬

X-Frame-Options â†’ ç¼ºå¤± â†’ é»æ“ŠåŠ«æŒé¢¨éšª

Content-Security-Policy â†’ ç¼ºå¤± â†’ XSS é¢¨éšª

çµæœï¼š é¡¯ç¤º header å€¼æˆ–ã€Œç¼ºå¤±ã€ã€‚

4.4 æª¢æŸ¥æ˜¯å¦ä½¿ç”¨ HTTPS
åˆ¤æ–·ï¼š

port = 443 æˆ– URL = https â†’ ã€Œå·²ä½¿ç”¨ HTTPSã€

å¦å‰‡ â†’ ã€Œæœªä½¿ç”¨ HTTPSã€

4.5 æª¢æŸ¥ TLS ç‰ˆæœ¬ï¼ˆç°¡åŒ–ç‰ˆï¼‰
æ–¹æ³•ï¼š ä½¿ç”¨ ssl æ¨¡çµ„å»ºç«‹ socketï¼Œè®€å–å”å®šç‰ˆæœ¬ï¼š

import ssl, socket ctx = ssl.create_default_context() with socket.create_connection(("127.0.0.1", 443)) as sock: with ctx.wrap_socket(sock, server_hostname="127.0.0.1") as ssock: print(ssock.version())

è¼¸å‡ºï¼š TLSv1.2ã€TLSv1.3 ç­‰ã€‚

4.6 åˆ¤æ–·æ˜¯å¦å¼± TLS
åˆ¤æ–·ï¼š

TLSv1.0 æˆ– TLSv1.1 â†’ ã€Œå¼± TLSã€

TLSv1.2 æˆ– TLSv1.3 â†’ ã€Œå®‰å…¨ã€


4.7å®‰è£requestså¥—ä»¶
venv/Scripts/pip install requests



http_check.pyç¯„ä¾‹

import requests
import ssl
import socket

# -------------------------
# 4.1 ç™¼é€ GET /
# -------------------------
def fetch_http(target_ip, port=80, use_https=False):
    scheme = "https" if use_https else "http"
    url = f"{scheme}://{target_ip}:{port}/"
    try:
        resp = requests.get(url, timeout=3)
        return resp
    except Exception as e:
        return None

# -------------------------
# 4.2 æª¢æŸ¥ directory listing
# -------------------------
def check_directory_listing(body: str) -> str:
    if "<title>Index of /</title>" in body or "Index of /" in body:
        return "å¯èƒ½å­˜åœ¨ç›®éŒ„åˆ—å‡ºæ¼æ´"
    return "æœªç™¼ç¾ç›®éŒ„åˆ—å‡º"

# -------------------------
# 4.3 æª¢æŸ¥æ•æ„Ÿ header
# -------------------------
def check_sensitive_headers(headers: dict) -> dict:
    checks = ["Server", "X-Powered-By", "X-AspNet-Version", 
              "X-Frame-Options", "Content-Security-Policy"]
    results = {}
    for h in checks:
        results[h] = headers.get(h, "ç¼ºå¤±")
    return results

# -------------------------
# 4.4 + 4.5 + 4.6 æª¢æŸ¥ HTTPS èˆ‡ TLS
# -------------------------
def check_tls(target_ip, port=443):
    try:
        ctx = ssl.create_default_context()
        with socket.create_connection((target_ip, port), timeout=3) as sock:
            with ctx.wrap_socket(sock, server_hostname=target_ip) as ssock:
                version = ssock.version()
                if version in ["TLSv1", "TLSv1.1"]:
                    return f"{version} â†’ å¼± TLS"
                else:
                    return f"{version} â†’ å®‰å…¨"
    except Exception:
        return "TLS æª¢æŸ¥å¤±æ•—"

# -------------------------
# ä¸»æª¢æŸ¥æµç¨‹
# -------------------------
def http_basic_check(target_ip, port=80, use_https=False):
    resp = fetch_http(target_ip, port, use_https)
    if not resp:
        return {"error": "HTTP è«‹æ±‚å¤±æ•—"}

    body = resp.text
    headers = resp.headers

    return {
        "status_code": resp.status_code,
        "directory_listing": check_directory_listing(body),
        "sensitive_headers": check_sensitive_headers(headers),
        "https_usage": "å·²ä½¿ç”¨ HTTPS" if use_https or port == 443 else "æœªä½¿ç”¨ HTTPS",
        "tls_check": check_tls(target_ip, 443) if use_https or port == 443 else "æœªæª¢æŸ¥ (é HTTPS)"
    }




å…¥å£ç¨‹å¼ç¢¼
scanner.py

from modules import port_scan, banner, version_compare, http_check

# -------------------------
# ä¸»ç¨‹å¼å…¥å£
# -------------------------
if __name__ == "__main__":
    target_ip = "127.0.0.1"
    ports = [22, 80, 443, 3306, 6379]
    #ssh, http, https, mysql, Redis

    open_ports = port_scan.port_scan(target_ip, ports)
    print("[+] Open Ports:", open_ports)

    banners = banner.grab_banners(target_ip, open_ports)
    print("[+] Banners:", banners)

    baseline = version_compare.load_baseline("data/known_versions.json")
    verdicts = version_compare.evaluate_banners(banners, baseline)
    for v in verdicts:
        print(f"- {v.get('port')}/tcp {v.get('service')} {v.get('version')} â†’ {v.get('status')}")

    # ç¬¬å››éšæ®µï¼šHTTP åŸºæœ¬æª¢æŸ¥ 
    if 80 in open_ports: 
        print("[+] HTTP Basic Check:") 
        result = http_check.http_basic_check(target_ip, 80, use_https=False) 
        print(result) 
    if 443 in open_ports: 
        print("[+] HTTPS Basic Check:") 
        result = http_check.http_basic_check(target_ip, 443, use_https=True) 
        print(result)
#
#å¯ä»¥ä½¿ç”¨python -m http.server 80
#æ¸¬è©¦æœ‰æ²’æœ‰è¾¦æ³•æˆåŠŸæƒææ­£åœ¨ç›£è½(å°å¤–é–‹æ”¾)çš„port