只要能夠進行banner掃描

入口
./scanner.py

from modules import port_scan, banner

# -------------------------
# 主程式入口
# -------------------------
if __name__ == "__main__":
    target_ip = "127.0.0.1"
    ports = [22, 80, 443, 3306, 6379]
    #ssh, http, https, mysql, Redis

    open_ports = port_scan.port_scan(target_ip, ports)
    print("[+] Open Ports:", open_ports)


#
#可以使用python -m http.server 80
#測試有沒有辦法成功掃描正在監聽(對外開放)的port

=================================================



modules/scan_port.py
import socket
from concurrent.futures import ThreadPoolExecutor

#使用socket管理網路通訊，使用ThreadPoolExecutor管理多執行緒

# -------------------------
# 1.1 決定掃描範圍
# -------------------------
def get_ports_to_scan(ports):
    return sorted(set(ports)) #由小到大排列


# -------------------------
# 1.2 + 1.3: TCP Connect Scan
# -------------------------
def scan_port(target_ip, port, timeout=0.5):
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.settimeout(timeout)

    try:
        result = sock.connect_ex((target_ip, port))
        if result == 0:
            return (port, "open")
        else:
            return (port, "closed")
    except Exception:
        return (port, "closed")
    finally:
        sock.close()


# -------------------------
# 1.4: 多執行緒掃描
# -------------------------
def port_scan(target_ip, ports, threads=100):
    ports_to_scan = get_ports_to_scan(ports)

    with ThreadPoolExecutor(max_workers=threads) as executor:
        results = executor.map(
            lambda p: scan_port(target_ip, p),
            ports_to_scan
        )

    open_ports = [port for port, status in results if status == "open"]
    
    return open_ports



====================================================


modules/banner.py
import socket

def grab_banner(target_ip, port, timeout=1):
    try:
        sock = socket.socket()
        sock.settimeout(timeout)
        sock.connect((target_ip, port))

        # 特殊處理 HTTP
        if port in [80, 443]:
            sock.sendall(b"GET / HTTP/1.0\r\n\r\n")

        banner = sock.recv(1024)
        return banner.decode(errors="ignore").strip()
    except Exception:
        return None
    finally:
        sock.close()

def grab_banners(target_ip, open_ports):
    results = {}
    for port in open_ports:
        banner = grab_banner(target_ip, port)
        if banner:
            results[port] = banner
    return results

========================================================================
就可以測試版本掃描功能


資料表設計與載入
• 	檔案位置： data/known_versions.json
• 	欄位設計： 以服務名稱為鍵，版本字串為值（可支援主版號.次版號.修訂號）
• 	示例：

{
    "OpenSSH": "8.0",
    "Apache": "2.4.50",
    "nginx": "1.20",
    "Postfix": "3.6",
    "vsFTPd": "3.0.3",
    "SimpleHTTP": "0.6",
    "Python": "3.14.2"
}


• 	載入策略： 啟動時一次載入並緩存；若檔案不存在，給出清楚錯誤或使用空 baseline。

從 banner 解析服務與版本
• 	核心思路： 對不同服務使用對應的 regex，把「服務名稱」與「版本字串」抽取出來。
• 	常見規則：
• 	SSH：
• 	模式：- SSH-2.0-OpenSSH_7.2p1
- 


• 	Apache：
• 	模式：

• 	nginx：
• 	模式：

• 	Postfix (SMTP)：
• 	模式：（可能不含版本；若含版本如 ）

• 	vsFTPd：
• 	模式：

• 	清洗細節：
• 	去除附註與後綴： 例如  → 取 
• 	大小寫不敏感： regex 使用 
• 	失敗容錯： 無法解析版本時，回傳  並標記為「未知版本」

版本標準化與比較
• 	標準化策略： 把版本字串拆成數字 tuple（長度對齊），例如：
• 	 → 
• 	 → 
• 	比較邏輯： 逐位比較主版號、次版號、修訂號：

• 	特例處理：
• 	後綴字母或 build 標記： 先剝離非數字與點（如 , ）
• 	缺位補零： 將  與  視為相同
• 	未知版本： 若無法解析版本但服務在 baseline 中，標記為「無法判定」

模組介面與程式骨架（version_compare.py）

import json
import re
from typing import Dict, Optional, Tuple

# -------------------------
# 3.1 載入 baseline
# -------------------------
def load_baseline(path: str = "data/known_versions.json") -> Dict[str, str]:
    try:
        with open(path, "r", encoding="utf-8") as f:
            return json.load(f)
    except Exception:
        return {}

# -------------------------
# 3.2 解析 banner → (service, version)
# -------------------------
SERVICE_PATTERNS = [
    ("OpenSSH", re.compile(r"OpenSSH[_-]?(\d+(?:\.\d+){0,2})", re.I)),
    ("Apache",  re.compile(r"Apache/(\d+(?:\.\d+){0,2})", re.I)),
    ("nginx",   re.compile(r"nginx/(\d+(?:\.\d+){0,2})", re.I)),
    ("Postfix", re.compile(r"Postfix\s+(\d+(?:\.\d+){0,2})", re.I)),
    ("vsFTPd",  re.compile(r"vsFTPd\s+(\d+(?:\.\d+){0,2})", re.I)),
    ("SimpleHTTP", re.compile(r"SimpleHTTP/(\d+(?:\.\d+)?)", re.I)),
    ("Python", re.compile(r"Python/(\d+(?:\.\d+)?)", re.I)),
]

def parse_banner(banner: str) -> Tuple[Optional[str], Optional[str]]:
    # 去除雜訊後再做匹配
    text = banner.strip()
    for service, pattern in SERVICE_PATTERNS:
        m = pattern.search(text)
        if m:
            raw_version = m.group(1)
            # 去除非數字與點的尾註，如 7.2p1 → 7.2
            cleaned = re.match(r"(\d+(?:\.\d+){0,2})", raw_version)
            return service, (cleaned.group(1) if cleaned else raw_version)
    return None, None

# -------------------------
# 3.3 版本標準化與比較
# -------------------------
def normalize(ver: str, width: int = 3) -> Tuple[int, int, int]:
    parts = re.findall(r"\d+", ver)
    nums = [int(p) for p in parts[:width]]
    while len(nums) < width:
        nums.append(0)
    return tuple(nums)  # e.g., ('2','4','41') → (2,4,41)

def is_outdated(detected: str, baseline: str) -> bool:
    return normalize(detected) < normalize(baseline)

# -------------------------
# 3.4 對多個 banner 做比對並輸出結果
# -------------------------
def evaluate_banners(banners: Dict[int, str], baseline_map: Dict[str, str]):
    results = []
    for port, banner in banners.items():
        service, version = parse_banner(banner)
        if not service or not version:
            results.append({
                "port": port,
                "service": service or "Unknown",
                "version": version or "Unknown",
                "status": "Unknown version (cannot parse)"
            })
            continue

        baseline = baseline_map.get(service)
        if not baseline:
            results.append({
                "port": port,
                "service": service,
                "version": version,
                "status": "No baseline (cannot judge)"
            })
            continue

        status = "Outdated" if is_outdated(version, baseline) else "OK"
        results.append({
            "port": port,
            "service": service,
            "version": version,
            "baseline": baseline,
            "status": status
        })
    return results



整合與呼叫示例（scanner.py）

from modules import port_scan, banner, version_compare

if __name__ == "__main__":
    target_ip = "127.0.0.1"
    ports = [22, 80, 443, 3306, 6379]

    open_ports = port_scan.port_scan(target_ip, ports)
    print("[+] Open Ports:", open_ports)

    banners = banner.grab_banners(target_ip, open_ports)
    print("[+] Banners:", banners)

    baseline = version_compare.load_baseline("data/known_versions.json")
    verdicts = version_compare.evaluate_banners(banners, baseline)
    for v in verdicts:
        print(f"- {v.get('port')}/tcp {v.get('service')} {v.get('version')} → {v.get('status')}")


測試要點與邊界情況
- 測試用服務：
- HTTP：python -m http.server 80（預期抓到 Server: SimpleHTTP/...）
- nginx/Apache：Docker 快速啟動，驗證解析與比對
- 未含版本的 banner： 有些 SMTP 只顯示產品名，不含版本 → 應標記為「Unknown version」
- 非 baseline 服務： 若解析到服務但 baseline 無對應 → 標記「No baseline」
- 特殊版本格式： 如 7.2p1、1.20-ubuntu2 → 先剝離尾註，保留數字與點
- 多行 banner： 先 .strip() 並在 regex 使用 re.S 或針對整段搜尋
- 一致性： 比較時將版本標準化為固定寬度 tuple，避免 1.2 vs 1.2.0 判斷不一致




